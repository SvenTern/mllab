"""
Fractional differentiation is a technique to make a time series stationary but also
retain as much memory as possible. This is done by differencing by a positive real
number. Fractionally differenced series can be used as a feature in machine learning
process.
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from statsmodels.tsa.stattools import adfuller


"""
FractionalDifferentiation class encapsulates the functions that can
be used to compute fractionally differentiated series.
"""


def get_weights(diff_amt, size):
    """
    Advances in Financial Machine Learning, Chapter 5, section 5.4.2, page 79.

    The helper function generates weights that are used to compute fractionally
    differentiated series. It computes the weights that get used in the computation
    of fractionally differentiated series. This generates a non-terminating series
    that approaches zero asymptotically. The side effect of this function is that
    it leads to negative drift "caused by an expanding window's added weights"
    (see page 83 AFML)

    When diff_amt is real (non-integer) positive number then it preserves memory.

    :param diff_amt: (float) Differencing amount
    :param size: (int) Length of the series
    :return: (np.ndarray) Weight vector
    """

    weights = [1.0]
    for k in range(1, size):
        weights.append(-weights[-1] * (diff_amt - k + 1) / k)
    return np.array(weights[::-1])


def frac_diff(series, diff_amt, thresh=0.01):
    """
    Advances in Financial Machine Learning, Chapter 5, section 5.5, page 82.

    References:
    https://www.wiley.com/en-us/Advances+in+Financial+Machine+Learning-p-9781119482086
    https://wwwf.imperial.ac.uk/~ejm/M3S8/Problems/hosking81.pdf
    https://en.wikipedia.org/wiki/Fractional_calculus

    The steps are as follows:
    - Compute weights (this is a one-time exercise)
    - Iteratively apply the weights to the price series and generate output points

    This is the expanding window variant of the fracDiff algorithm
    Note 1: For thresh-1, nothing is skipped
    Note 2: diff_amt can be any positive fractional, not necessarily bounded [0, 1]

    :param series: (pd.Series) A time series that needs to be differenced
    :param diff_amt: (float) Differencing amount
    :param thresh: (float) Threshold or epsilon
    :return: (pd.Series) Differenced series
    """

    weights = FractionalDifferentiation.get_weights(diff_amt, len(series))
    weights = weights[np.abs(weights) > thresh]
    output = pd.Series(index=series.index)

    for i in range(len(weights), len(series)):
        output.iloc[i] = np.dot(weights, series.iloc[i - len(weights):i])

    return output


def get_weights_ffd(diff_amt, thresh, lim):
    """
    Advances in Financial Machine Learning, Chapter 5, section 5.4.2, page 83.

    The helper function generates weights that are used to compute fractionally
    differentiated series. The series is of fixed width and same
    weights (generated by this function) can be used when creating fractional
    differentiated series.

    :param diff_amt: (float) Differencing amount
    :param thresh: (float) Threshold for minimum weight
    :param lim: (int) Maximum length of the weight vector
    :return: (np.ndarray) Weight vector
    """

    weights = [1.0]
    for k in range(1, lim):
        weight = -weights[-1] * (diff_amt - k + 1) / k
        if abs(weight) < thresh:
            break
        weights.append(weight)
    return np.array(weights[::-1])


def frac_diff_ffd(series, diff_amt, thresh=1e-5):
    """
    Advances in Financial Machine Learning, Chapter 5, section 5.5, page 83.

    References:

    * https://www.wiley.com/en-us/Advances+in+Financial+Machine+Learning-p-9781119482086
    * https://wwwf.imperial.ac.uk/~ejm/M3S8/Problems/hosking81.pdf
    * https://en.wikipedia.org/wiki/Fractional_calculus

    The steps are as follows:

    - Compute weights (this is a one-time exercise)
    - Iteratively apply the weights to the price series and generate output points

    Constant width window (new solution)
    Note 1: thresh determines the cut-off weight for the window
    Note 2: diff_amt can be any positive fractional, not necessarily bounded [0, 1].

    :param series: (pd.Series) A time series that needs to be differenced
    :param diff_amt: (float) Differencing amount
    :param thresh: (float) Threshold for minimum weight
    :return: (pd.Series) A data frame of differenced series
    """

    weights = FractionalDifferentiation.get_weights_ffd(diff_amt, thresh, len(series))
    output = pd.Series(index=series.index)

    for i in range(len(weights), len(series)):
        output.iloc[i] = np.dot(weights, series.iloc[i - len(weights):i])

    return output



def plot_min_ffd(series):
    """
    Advances in Financial Machine Learning, Chapter 5, section 5.6, page 85.

    This function plots the graph to find the minimum D value that passes the ADF test.

    :param series: (pd.Series) Time series data.
    :return: None
    """

    out = pd.DataFrame(columns=['d', 'adfStat', 'pVal', 'lags', 'nObs', '95% conf', 'corr'])
    for d in np.linspace(0, 1, 11):
        diff_series = FractionalDifferentiation.frac_diff_ffd(series, d)
        corr = np.corrcoef(series.loc[diff_series.index], diff_series)[0, 1]
        adf_test = adfuller(diff_series.dropna(), maxlag=1, regression='c', autolag=None)
        out.loc[d] = [d, adf_test[0], adf_test[1], adf_test[2], adf_test[3], adf_test[4]['5%'], corr]

    fig, ax1 = plt.subplots()
    ax1.plot(out['d'], out['corr'], color='blue')
    ax1.set_xlabel('d')
    ax1.set_ylabel('Correlation', color='blue')
    ax2 = ax1.twinx()
    ax2.plot(out['d'], out['adfStat'], color='red')
    ax2.axhline(out['95% conf'].mean(), color='black', linestyle='--')
    ax2.set_ylabel('ADF Statistic', color='red')
    plt.title('ADF Statistic and Correlation vs Differencing Amount')
    plt.show()
